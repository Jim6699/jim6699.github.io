<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>手势识别监控系统 v3.0 - 特征查看与画面遮罩</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Courier New', monospace;
        }

        body {
            background-color: #0a0a0a;
            color: #0af20a;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* 黑客风格终端标题栏 */
        .header {
            background-color: #001100;
            border-bottom: 1px solid #0af20a;
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 0 15px rgba(10, 242, 10, 0.2);
            position: relative;
        }

        .header::after {
            content: "";
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 1px;
            background: linear-gradient(90deg, transparent, #0af20a, transparent);
        }

        .header h1 {
            font-size: 1.8rem;
            letter-spacing: 2px;
            text-shadow: 0 0 10px #0af20a;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .header h1 i {
            color: #00ffff;
        }

        .status-light {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #0af20a;
            box-shadow: 0 0 10px #0af20a;
            margin-right: 10px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .timestamp {
            color: #00ffff;
            font-size: 0.9rem;
            letter-spacing: 1px;
        }

        /* 主要内容区域 */
        .main-container {
            display: flex;
            flex: 1;
            padding: 20px;
            gap: 20px;
            overflow: hidden;
        }

        /* 左侧摄像头视图 */
        .camera-view {
            flex: 1;
            display: flex;
            flex-direction: column;
            background-color: #001a00;
            border: 1px solid #0af20a;
            border-radius: 5px;
            padding: 20px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(10, 242, 10, 0.1);
        }

        .camera-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px dashed #0af20a;
        }

        .camera-title {
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 10px;
            color: #00ffff;
        }

        .camera-fps {
            color: #ffaa00;
            font-size: 0.9rem;
        }

        .video-container {
            position: relative;
            flex: 1;
            background-color: #000;
            border: 1px solid #0af20a;
            border-radius: 3px;
            overflow: hidden;
        }

        #input-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* 镜像 */
        }

        #canvas-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* 视频遮罩层 */
        .video-mask {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            pointer-events: none;
            z-index: 5;
        }

        /* 遮罩控制 */
        .mask-control {
            margin-top: 15px;
            padding: 10px;
            background-color: #001100;
            border: 1px solid #0af20a;
            border-radius: 3px;
        }

        .mask-control-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .mask-title {
            color: #00ffff;
            font-size: 1rem;
        }

        .mask-value {
            color: #ffaa00;
            font-weight: bold;
        }

        .mask-slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .mask-slider {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: #001a00;
            border-radius: 4px;
            outline: none;
        }

        .mask-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #0af20a;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(10, 242, 10, 0.5);
        }

        .mask-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #0af20a;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(10, 242, 10, 0.5);
            border: none;
        }

        .mask-icon {
            color: #0af20a;
            font-size: 1.2rem;
        }

        /* 右侧状态面板 */
        .status-panel {
            width: 450px;
            display: flex;
            flex-direction: column;
            background-color: #001a00;
            border: 1px solid #0af20a;
            border-radius: 5px;
            padding: 20px;
            box-shadow: 0 0 20px rgba(10, 242, 10, 0.1);
            overflow: hidden;
        }

        .panel-header {
            font-size: 1.3rem;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px dashed #0af20a;
            color: #00ffff;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* 系统状态 */
        .system-status {
            background-color: #000;
            border: 1px solid #0af20a;
            border-radius: 3px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px dotted #0a4a0a;
        }

        .status-item:last-child {
            margin-bottom: 0;
            border-bottom: none;
        }

        .status-label {
            color: #0af20a;
        }

        .status-value {
            font-weight: bold;
        }

        .status-value.good {
            color: #0af20a;
        }

        .status-value.warning {
            color: #ffaa00;
        }

        .status-value.error {
            color: #ff3300;
        }

        /* 手势识别结果 */
        .gesture-results {
            background-color: #000;
            border: 1px solid #0af20a;
            border-radius: 3px;
            padding: 15px;
            margin-bottom: 20px;
            flex: 1;
            overflow-y: auto;
        }

        .gesture-results::-webkit-scrollbar {
            width: 6px;
        }

        .gesture-results::-webkit-scrollbar-track {
            background: #001a00;
        }

        .gesture-results::-webkit-scrollbar-thumb {
            background: #0af20a;
            border-radius: 3px;
        }

        .current-gesture {
            text-align: center;
            font-size: 1.8rem;
            margin-bottom: 20px;
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-bottom: 1px dashed #0a4a0a;
            padding-bottom: 15px;
        }

        .gesture-history {
            margin-top: 15px;
        }

        .history-title {
            color: #0af20a;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .history-list {
            list-style-type: none;
        }

        .history-item {
            padding: 8px 10px;
            margin-bottom: 5px;
            background-color: #001100;
            border-left: 3px solid #0af20a;
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
        }

        .history-item:nth-child(odd) {
            background-color: #001a00;
        }

        .history-time {
            color: #ffaa00;
            font-size: 0.8rem;
        }

        /* 自定义手势面板 */
        .custom-gesture-panel {
            background-color: #000;
            border: 1px solid #ffaa00;
            border-radius: 3px;
            padding: 15px;
            margin-bottom: 20px;
            display: none; /* 默认隐藏，通过按钮打开 */
        }

        .custom-gesture-panel.active {
            display: block;
        }

        .custom-gesture-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            color: #ffaa00;
        }

        .custom-gesture-form {
            margin-bottom: 15px;
        }

        .form-group {
            margin-bottom: 12px;
        }

        .form-label {
            display: block;
            margin-bottom: 5px;
            color: #0af20a;
        }

        .form-input {
            width: 100%;
            padding: 8px 10px;
            background-color: #001a00;
            border: 1px solid #0af20a;
            color: #0af20a;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }

        .form-input:focus {
            outline: none;
            box-shadow: 0 0 5px rgba(10, 242, 10, 0.5);
        }

        .form-buttons {
            display: flex;
            gap: 10px;
        }

        .form-btn {
            flex: 1;
            padding: 10px;
            background-color: #001a00;
            border: 1px solid;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s;
        }

        .form-btn.primary {
            border-color: #00ffff;
            color: #00ffff;
        }

        .form-btn.primary:hover {
            background-color: #003333;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }

        .form-btn.secondary {
            border-color: #ffaa00;
            color: #ffaa00;
        }

        .form-btn.secondary:hover {
            background-color: #333300;
            box-shadow: 0 0 10px rgba(255, 170, 0, 0.3);
        }

        .form-btn.danger {
            border-color: #ff3300;
            color: #ff3300;
        }

        .form-btn.danger:hover {
            background-color: #330000;
            box-shadow: 0 0 10px rgba(255, 51, 0, 0.3);
        }

        .form-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .recording-indicator {
            display: none;
            align-items: center;
            gap: 8px;
            color: #ff3300;
            margin-bottom: 10px;
            padding: 8px;
            background-color: #330000;
            border-radius: 3px;
        }

        .recording-indicator.active {
            display: flex;
        }

        .recording-dot {
            width: 12px;
            height: 12px;
            background-color: #ff3300;
            border-radius: 50%;
            animation: recordingPulse 1.5s infinite;
        }

        @keyframes recordingPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .samples-counter {
            text-align: center;
            color: #ffaa00;
            margin-bottom: 10px;
            font-size: 0.9rem;
        }

        /* 自定义手势列表 */
        .custom-gesture-list {
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
        }

        .custom-gesture-list::-webkit-scrollbar {
            width: 6px;
        }

        .custom-gesture-list::-webkit-scrollbar-track {
            background: #001a00;
        }

        .custom-gesture-list::-webkit-scrollbar-thumb {
            background: #ffaa00;
            border-radius: 3px;
        }

        .custom-gesture-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin-bottom: 8px;
            background-color: #001100;
            border-left: 3px solid #ffaa00;
            border-radius: 3px;
        }

        .custom-gesture-info {
            display: flex;
            flex-direction: column;
        }

        .custom-gesture-name {
            color: #00ffff;
            font-weight: bold;
        }

        .custom-gesture-samples {
            color: #ffaa00;
            font-size: 0.8rem;
        }

        .custom-gesture-actions {
            display: flex;
            gap: 5px;
        }

        .custom-gesture-btn {
            padding: 5px 8px;
            background-color: #002200;
            border: 1px solid #0af20a;
            color: #0af20a;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .custom-gesture-btn:hover {
            background-color: #0a4a0a;
        }

        /* 特征值查看器 */
        .feature-viewer {
            background-color: #000;
            border: 1px solid #00ffff;
            border-radius: 3px;
            padding: 15px;
            margin-top: 20px;
            display: none;
            max-height: 300px;
            overflow-y: auto;
        }

        .feature-viewer.active {
            display: block;
        }

        .feature-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            color: #00ffff;
        }

        .feature-content {
            background-color: #001100;
            padding: 15px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            line-height: 1.4;
            white-space: pre-wrap;
            overflow-x: auto;
        }

        .feature-item {
            margin-bottom: 8px;
            padding: 8px;
            background-color: #000;
            border-left: 2px solid #0af20a;
        }

        .feature-key {
            color: #00ffff;
            font-weight: bold;
            margin-right: 10px;
        }

        .feature-value {
            color: #ffaa00;
            word-break: break-all;
        }

        .feature-sample {
            margin-bottom: 15px;
            padding: 10px;
            background-color: #001a00;
            border-radius: 3px;
        }

        .feature-sample-title {
            color: #0af20a;
            margin-bottom: 5px;
            font-weight: bold;
        }

        /* 代码查看器 */
        .code-viewer {
            background-color: #000;
            border: 1px solid #0af20a;
            border-radius: 3px;
            padding: 15px;
            margin-top: 20px;
            display: none;
            max-height: 300px;
            overflow-y: auto;
        }

        .code-viewer.active {
            display: block;
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            color: #00ffff;
        }

        .code-content {
            background-color: #001100;
            padding: 15px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            line-height: 1.4;
            white-space: pre-wrap;
            overflow-x: auto;
        }

        .code-line {
            margin-bottom: 5px;
        }

        .code-keyword {
            color: #ff6600;
        }

        .code-function {
            color: #00ffff;
        }

        .code-string {
            color: #00ff00;
        }

        .code-comment {
            color: #888888;
        }

        .code-number {
            color: #ffaa00;
        }

        /* 控制面板 */
        .control-panel {
            background-color: #000;
            border: 1px solid #0af20a;
            border-radius: 3px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .control-title {
            color: #0af20a;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .control-btn {
            flex: 1;
            padding: 10px;
            background-color: #001a00;
            border: 1px solid #0af20a;
            color: #0af20a;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s;
            min-width: 120px;
        }

        .control-btn:hover {
            background-color: #0a4a0a;
            box-shadow: 0 0 10px rgba(10, 242, 10, 0.3);
        }

        .control-btn.active {
            background-color: #0a4a0a;
            box-shadow: 0 0 10px rgba(10, 242, 10, 0.5);
        }

        /* 终端输出 */
        .terminal-output {
            flex: 1;
            background-color: #000;
            border: 1px solid #0af20a;
            border-radius: 3px;
            padding: 15px;
            margin-top: 20px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            overflow-y: auto;
            max-height: 200px;
        }

        .terminal-output::-webkit-scrollbar {
            width: 6px;
        }

        .terminal-output::-webkit-scrollbar-track {
            background: #001a00;
        }

        .terminal-output::-webkit-scrollbar-thumb {
            background: #0af20a;
            border-radius: 3px;
        }

        .terminal-line {
            margin-bottom: 5px;
            line-height: 1.3;
        }

        .terminal-prompt {
            color: #00ffff;
            margin-right: 5px;
        }

        /* 加载遮罩 */
        .loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 20, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: #0af20a;
        }

        .loader-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid transparent;
            border-top: 4px solid #0af20a;
            border-right: 4px solid #0af20a;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        .loader-text {
            font-size: 1.2rem;
            text-align: center;
            line-height: 1.5;
        }

        .loader-dots {
            display: inline-block;
            width: 10px;
        }

        .loader-dots::after {
            content: '...';
            animation: dots 1.5s steps(4, end) infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }

        /* 数据流效果 */
        .data-stream {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
            opacity: 0.1;
        }

        .stream-line {
            position: absolute;
            width: 1px;
            height: 100px;
            background: linear-gradient(to bottom, transparent, #0af20a, transparent);
            animation: streamFall linear infinite;
        }

        @keyframes streamFall {
            from {
                transform: translateY(-100px);
            }
            to {
                transform: translateY(100vh);
            }
        }

        /* 响应式设计 */
        @media (max-width: 1200px) {
            .main-container {
                flex-direction: column;
                height: auto;
            }
            
            .status-panel {
                width: 100%;
                margin-top: 20px;
            }
            
            .camera-view {
                min-height: 500px;
            }
        }
    </style>
    
    <!-- 引入 MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>
    <!-- 数据流背景效果 -->
    <div class="data-stream" id="data-stream"></div>
    
    <!-- 加载界面 -->
    <div class="loader" id="loader">
        <div class="loader-spinner"></div>
        <div class="loader-text">
            正在启动手势识别系统<span class="loader-dots"></span><br>
            <span style="font-size: 0.9rem; color: #00ffff;">请允许摄像头访问权限</span>
        </div>
    </div>

    <!-- 头部 -->
    <div class="header">
        <h1>
            <span class="status-light"></span>
            <i class="fas fa-hand-pointer"></i> 手势识别监控系统 v3.0
        </h1>
        <div class="timestamp" id="timestamp">00:00:00</div>
    </div>

    <!-- 主要内容区域 -->
    <div class="main-container">
        <!-- 左侧摄像头视图 -->
        <div class="camera-view">
            <div class="camera-header">
                <div class="camera-title">
                    <i class="fas fa-video"></i> 实时摄像头画面
                </div>
                <div class="camera-fps" id="fps-counter">FPS: --</div>
            </div>
            <div class="video-container">
                <video id="input-video" playsinline></video>
                <canvas id="canvas-overlay"></canvas>
                <div class="video-mask" id="video-mask"></div>
            </div>
            
            <!-- 遮罩控制 -->
            <div class="mask-control">
                <div class="mask-control-header">
                    <div class="mask-title">
                        <i class="fas fa-mask"></i> 画面遮罩控制
                    </div>
                    <div class="mask-value" id="mask-value">50%</div>
                </div>
                <div class="mask-slider-container">
                    <i class="fas fa-sun mask-icon"></i>
                    <input type="range" min="0" max="100" value="50" class="mask-slider" id="mask-slider">
                    <i class="fas fa-moon mask-icon"></i>
                </div>
            </div>
        </div>

        <!-- 右侧状态面板 -->
        <div class="status-panel">
            <div class="panel-header">
                <i class="fas fa-chart-bar"></i> 系统状态监控
            </div>

            <!-- 系统状态 -->
            <div class="system-status">
                <div class="status-item">
                    <span class="status-label">系统状态</span>
                    <span class="status-value good" id="sys-status">运行中</span>
                </div>
                <div class="status-item">
                    <span class="status-label">摄像头</span>
                    <span class="status-value good" id="camera-status">已连接</span>
                </div>
                <div class="status-item">
                    <span class="status-label">模型状态</span>
                    <span class="status-value good" id="model-status">已加载</span>
                </div>
                <div class="status-item">
                    <span class="status-label">检测到的手</span>
                    <span class="status-value" id="hands-detected">0</span>
                </div>
                <div class="status-item">
                    <span class="status-label">检测置信度</span>
                    <span class="status-value" id="detection-confidence">--</span>
                </div>
                <div class="status-item">
                    <span class="status-label">自定义手势</span>
                    <span class="status-value" id="custom-gestures-count">0</span>
                </div>
            </div>

            <!-- 手势识别结果 -->
            <div class="gesture-results">
                <div class="current-gesture" id="current-gesture">
                    等待识别...
                </div>
                <div class="gesture-history">
                    <div class="history-title">
                        <span>识别历史</span>
                        <span id="history-count">0 条记录</span>
                    </div>
                    <ul class="history-list" id="history-list">
                        <!-- 历史记录将通过JS动态添加 -->
                    </ul>
                </div>
            </div>

            <!-- 自定义手势面板 -->
            <div class="custom-gesture-panel" id="custom-gesture-panel">
                <div class="custom-gesture-header">
                    <h3><i class="fas fa-hand-sparkles"></i> 自定义手势训练</h3>
                    <button class="form-btn secondary" id="close-custom-panel">关闭</button>
                </div>
                
                <div class="recording-indicator" id="recording-indicator">
                    <div class="recording-dot"></div>
                    <span>正在录制样本...</span>
                </div>
                
                <div class="custom-gesture-form">
                    <div class="form-group">
                        <label class="form-label" for="gesture-name">手势名称</label>
                        <input type="text" id="gesture-name" class="form-input" placeholder="例如：我的特殊手势">
                    </div>
                    
                    <div class="samples-counter" id="samples-counter">
                        已录制样本: <span id="samples-count">0</span>/20
                    </div>
                    
                    <div class="form-buttons">
                        <button class="form-btn primary" id="start-recording">
                            <i class="fas fa-circle"></i> 开始录制
                        </button>
                        <button class="form-btn secondary" id="stop-recording" disabled>
                            <i class="fas fa-stop"></i> 停止录制
                        </button>
                        <button class="form-btn danger" id="train-gesture" disabled>
                            <i class="fas fa-brain"></i> 训练模型
                        </button>
                    </div>
                </div>
                
                <div class="custom-gesture-list" id="custom-gesture-list">
                    <!-- 自定义手势列表将通过JS动态添加 -->
                </div>
            </div>

            <!-- 特征值查看器 -->
            <div class="feature-viewer" id="feature-viewer">
                <div class="feature-header">
                    <h3><i class="fas fa-chart-line"></i> 手势特征值</h3>
                    <button class="form-btn secondary" id="close-feature-viewer">关闭</button>
                </div>
                <div class="feature-content" id="feature-content">
                    <!-- 特征值内容将通过JS动态添加 -->
                </div>
            </div>

            <!-- 代码查看器 -->
            <div class="code-viewer" id="code-viewer">
                <div class="code-header">
                    <h3><i class="fas fa-code"></i> 底层实现代码</h3>
                    <button class="form-btn secondary" id="close-code-viewer">关闭</button>
                </div>
                <div class="code-content" id="code-content">
                    <!-- 代码内容将通过JS动态添加 -->
                </div>
            </div>

            <!-- 控制面板 -->
            <div class="control-panel">
                <div class="control-title">
                    <i class="fas fa-sliders-h"></i> 控制选项
                </div>
                <div class="control-buttons">
                    <button class="control-btn" id="toggle-camera">
                        <i class="fas fa-video"></i> 切换摄像头
                    </button>
                    <button class="control-btn" id="toggle-visuals">
                        <i class="fas fa-eye"></i> 显示关键点
                    </button>
                    <button class="control-btn" id="toggle-custom-gesture">
                        <i class="fas fa-hand-sparkles"></i> 自定义手势
                    </button>
                    <button class="control-btn" id="toggle-code-viewer">
                        <i class="fas fa-code"></i> 查看代码
                    </button>
                    <button class="control-btn" id="clear-history">
                        <i class="fas fa-trash"></i> 清除历史
                    </button>
                </div>
            </div>

            <!-- 终端输出 -->
            <div class="terminal-output" id="terminal-output">
                <div class="terminal-line"><span class="terminal-prompt">>></span> 系统启动...</div>
                <div class="terminal-line"><span class="terminal-prompt">>></span> 初始化 MediaPipe Hands 模型...</div>
                <div class="terminal-line"><span class="terminal-prompt">>></span> 正在请求摄像头权限...</div>
                <!-- 终端输出将通过JS动态添加 -->
            </div>
        </div>
    </div>

    <script>
        // ==========================================
        // 1. 系统变量初始化
        // ==========================================
        let hands = null;
        let camera = null;
        let currentStream = null;
        let currentFPS = 0;
        let frameCount = 0;
        let lastFrameTime = Date.now();
        let detectionActive = true;
        let showVisuals = true;
        let showDataStream = true;
        let gestureHistory = [];
        let terminalLogs = [];
        let lastGesture = '';
        let lastGestureTime = 0;
        
        // 自定义手势相关变量
        let isRecording = false;
        let currentGestureName = '';
        let recordedSamples = [];
        let customGestures = [];
        let gestureClassifier = null;
        let isTraining = false;
        
        // 视频遮罩相关变量
        let maskOpacity = 0.5;

        // DOM元素引用
        const videoElement = document.getElementById('input-video');
        const canvasElement = document.getElementById('canvas-overlay');
        const canvasCtx = canvasElement.getContext('2d');
        const loader = document.getElementById('loader');
        const fpsCounter = document.getElementById('fps-counter');
        const sysStatus = document.getElementById('sys-status');
        const cameraStatus = document.getElementById('camera-status');
        const modelStatus = document.getElementById('model-status');
        const handsDetected = document.getElementById('hands-detected');
        const detectionConfidence = document.getElementById('detection-confidence');
        const customGesturesCount = document.getElementById('custom-gestures-count');
        const currentGesture = document.getElementById('current-gesture');
        const historyList = document.getElementById('history-list');
        const historyCount = document.getElementById('history-count');
        const terminalOutput = document.getElementById('terminal-output');
        const timestamp = document.getElementById('timestamp');
        const dataStream = document.getElementById('data-stream');
        
        // 自定义手势相关DOM元素
        const customGesturePanel = document.getElementById('custom-gesture-panel');
        const closeCustomPanelBtn = document.getElementById('close-custom-panel');
        const recordingIndicator = document.getElementById('recording-indicator');
        const gestureNameInput = document.getElementById('gesture-name');
        const samplesCounter = document.getElementById('samples-counter');
        const samplesCount = document.getElementById('samples-count');
        const startRecordingBtn = document.getElementById('start-recording');
        const stopRecordingBtn = document.getElementById('stop-recording');
        const trainGestureBtn = document.getElementById('train-gesture');
        const customGestureList = document.getElementById('custom-gesture-list');
        const toggleCustomGestureBtn = document.getElementById('toggle-custom-gesture');
        
        // 特征值查看器相关DOM元素
        const featureViewer = document.getElementById('feature-viewer');
        const featureContent = document.getElementById('feature-content');
        const closeFeatureViewerBtn = document.getElementById('close-feature-viewer');
        
        // 代码查看器相关DOM元素
        const codeViewer = document.getElementById('code-viewer');
        const codeContent = document.getElementById('code-content');
        const closeCodeViewerBtn = document.getElementById('close-code-viewer');
        const toggleCodeViewerBtn = document.getElementById('toggle-code-viewer');
        
        // 视频遮罩相关DOM元素
        const videoMask = document.getElementById('video-mask');
        const maskSlider = document.getElementById('mask-slider');
        const maskValue = document.getElementById('mask-value');

        // ==========================================
        // 2. 初始化数据流背景效果
        // ==========================================
        function initDataStream() {
            // 清除现有数据流
            dataStream.innerHTML = '';
            
            if (!showDataStream) return;
            
            // 创建多条数据流线
            for (let i = 0; i < 30; i++) {
                const line = document.createElement('div');
                line.className = 'stream-line';
                // 随机位置
                line.style.left = `${Math.random() * 100}%`;
                // 随机高度
                line.style.height = `${50 + Math.random() * 150}px`;
                // 随机动画时长
                const duration = 2 + Math.random() * 4;
                line.style.animationDuration = `${duration}s`;
                // 随机延迟
                line.style.animationDelay = `${Math.random() * 5}s`;
                // 随机透明度
                line.style.opacity = 0.1 + Math.random() * 0.2;
                
                dataStream.appendChild(line);
            }
        }

        // ==========================================
        // 3. 初始化 MediaPipe Hands
        // ==========================================
        function initializeMediaPipe() {
            logToTerminal('正在初始化 MediaPipe Hands 模型...');
            
            hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }
            });

            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onResults);
            
            logToTerminal('MediaPipe Hands 模型初始化完成。');
            modelStatus.textContent = '已加载';
            modelStatus.className = 'status-value good';
        }

        // ==========================================
        // 4. 手势识别结果处理
        // ==========================================
        function onResults(results) {
            // 更新FPS计数器
            updateFPS();
            
            // 清除画布
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            // 绘制摄像头画面
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            
            // 如果显示视觉标识且检测到手
            if (showVisuals && results.multiHandLandmarks) {
                // 绘制手部关键点和连接线
                drawHandLandmarks(results.multiHandLandmarks, results.multiHandedness);
                
                // 更新检测信息
                updateDetectionInfo(results);
                
                // 识别手势
                if (results.multiHandLandmarks.length > 0) {
                    const gesture = recognizeGesture(results.multiHandLandmarks[0]);
                    
                    // 检查是否匹配自定义手势
                    if (gestureClassifier && customGestures.length > 0) {
                        const customGesture = matchCustomGesture(results.multiHandLandmarks[0]);
                        if (customGesture) {
                            updateGestureDisplay(`[自定义] ${customGesture}`);
                            lastGesture = customGesture;
                            lastGestureTime = Date.now();
                        } else if (gesture && gesture !== lastGesture) {
                            updateGestureDisplay(gesture);
                            lastGesture = gesture;
                            lastGestureTime = Date.now();
                        }
                    } else if (gesture && gesture !== lastGesture) {
                        updateGestureDisplay(gesture);
                        lastGesture = gesture;
                        lastGestureTime = Date.now();
                    }
                    
                    // 录制样本（如果正在录制）
                    if (isRecording && results.multiHandLandmarks.length > 0) {
                        recordSample(results.multiHandLandmarks[0]);
                    }
                } else {
                    currentGesture.textContent = '未检测到手部';
                    currentGesture.style.color = '#ffaa00';
                }
            } else if (results.multiHandLandmarks) {
                // 仅更新检测信息，不绘制
                updateDetectionInfo(results);
                
                // 识别手势
                if (results.multiHandLandmarks.length > 0) {
                    const gesture = recognizeGesture(results.multiHandLandmarks[0]);
                    
                    // 检查是否匹配自定义手势
                    if (gestureClassifier && customGestures.length > 0) {
                        const customGesture = matchCustomGesture(results.multiHandLandmarks[0]);
                        if (customGesture) {
                            updateGestureDisplay(`[自定义] ${customGesture}`);
                            lastGesture = customGesture;
                            lastGestureTime = Date.now();
                        } else if (gesture && gesture !== lastGesture) {
                            updateGestureDisplay(gesture);
                            lastGesture = gesture;
                            lastGestureTime = Date.now();
                        }
                    } else if (gesture && gesture !== lastGesture) {
                        updateGestureDisplay(gesture);
                        lastGesture = gesture;
                        lastGestureTime = Date.now();
                    }
                    
                    // 录制样本（如果正在录制）
                    if (isRecording && results.multiHandLandmarks.length > 0) {
                        recordSample(results.multiHandLandmarks[0]);
                    }
                } else {
                    currentGesture.textContent = '未检测到手部';
                    currentGesture.style.color = '#ffaa00';
                }
            } else {
                // 没有检测到手
                currentGesture.textContent = '未检测到手部';
                currentGesture.style.color = '#ffaa00';
                handsDetected.textContent = '0';
                detectionConfidence.textContent = '--';
            }
            
            canvasCtx.restore();
            
            // 如果距离上次检测到手已经超过2秒，清除当前手势显示
            if (Date.now() - lastGestureTime > 2000 && lastGesture !== '') {
                lastGesture = '';
                currentGesture.textContent = '等待识别...';
                currentGesture.style.color = '#00ffff';
            }
        }

        // ==========================================
        // 5. 绘制手部关键点和连接线
        // ==========================================
        function drawHandLandmarks(landmarks, handedness) {
            // 设置绘制样式
            canvasCtx.lineWidth = 2;
            canvasCtx.strokeStyle = '#00ffff';
            canvasCtx.fillStyle = '#ff3300';
            
            // 绘制连接线
            const connections = [
                [0, 1], [1, 2], [2, 3], [3, 4], // 拇指
                [0, 5], [5, 6], [6, 7], [7, 8], // 食指
                [0, 9], [9, 10], [10, 11], [11, 12], // 中指
                [0, 13], [13, 14], [14, 15], [15, 16], // 无名指
                [0, 17], [17, 18], [18, 19], [19, 20], // 小指
                [5, 9], [9, 13], [13, 17] // 手掌
            ];
            
            for (let i = 0; i < landmarks.length; i++) {
                // 获取手性（左手或右手）
                const handType = handedness[i].label;
                canvasCtx.strokeStyle = handType === 'Left' ? '#00ff00' : '#00ffff';
                canvasCtx.fillStyle = handType === 'Left' ? '#00aa00' : '#0088aa';
                
                // 绘制连接线
                for (const [start, end] of connections) {
                    canvasCtx.beginPath();
                    canvasCtx.moveTo(
                        landmarks[i][start].x * canvasElement.width,
                        landmarks[i][start].y * canvasElement.height
                    );
                    canvasCtx.lineTo(
                        landmarks[i][end].x * canvasElement.width,
                        landmarks[i][end].y * canvasElement.height
                    );
                    canvasCtx.stroke();
                }
                
                // 绘制关键点
                for (const landmark of landmarks[i]) {
                    canvasCtx.beginPath();
                    canvasCtx.arc(
                        landmark.x * canvasElement.width,
                        landmark.y * canvasElement.height,
                        4, 0, 2 * Math.PI
                    );
                    canvasCtx.fill();
                }
                
                // 在手腕处显示手性标签
                canvasCtx.fillStyle = handType === 'Left' ? '#00ff00' : '#00ffff';
                canvasCtx.font = '14px Courier New';
                canvasCtx.fillText(
                    handType,
                    landmarks[i][0].x * canvasElement.width - 15,
                    landmarks[i][0].y * canvasElement.height - 10
                );
            }
        }

        // ==========================================
        // 6. 手势识别逻辑
        // ==========================================
        function recognizeGesture(landmarks) {
            // 计算关键点之间的距离
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const middleTip = landmarks[12];
            const ringTip = landmarks[16];
            const pinkyTip = landmarks[20];
            const wrist = landmarks[0];
            
            // 计算指尖到手腕的距离
            const thumbDistance = distance(thumbTip, wrist);
            const indexDistance = distance(indexTip, wrist);
            const middleDistance = distance(middleTip, wrist);
            const ringDistance = distance(ringTip, wrist);
            const pinkyDistance = distance(pinkyTip, wrist);
            
            // 计算指尖之间的距离
            const thumbIndexDistance = distance(thumbTip, indexTip);
            const indexMiddleDistance = distance(indexTip, middleTip);
            const middleRingDistance = distance(middleTip, ringTip);
            const ringPinkyDistance = distance(ringTip, pinkyTip);
            
            // 手势判断逻辑
            // 1. 捏合手势 (拇指和食指靠近)
            if (thumbIndexDistance < 0.05) {
                return "捏合手势";
            }
            
            // 2. 握拳 (所有指尖靠近手腕)
            if (thumbDistance < 0.15 && indexDistance < 0.15 && 
                middleDistance < 0.15 && ringDistance < 0.15 && pinkyDistance < 0.15) {
                return "握拳";
            }
            
            // 3. 手掌张开 (所有指尖远离手腕)
            if (thumbDistance > 0.3 && indexDistance > 0.3 && 
                middleDistance > 0.3 && ringDistance > 0.3 && pinkyDistance > 0.3) {
                return "手掌张开";
            }
            
            // 4. 胜利手势 (食指和中指张开，其他手指闭合)
            if (indexDistance > 0.25 && middleDistance > 0.25 && 
                thumbDistance < 0.2 && ringDistance < 0.2 && pinkyDistance < 0.2) {
                return "胜利手势";
            }
            
            // 5. OK手势 (拇指和食指形成圆圈，其他手指张开)
            if (thumbIndexDistance < 0.03 && 
                middleDistance > 0.25 && ringDistance > 0.25 && pinkyDistance > 0.25) {
                return "OK手势";
            }
            
            // 6. 指向手势 (食指向外延伸，其他手指闭合)
            if (indexDistance > 0.3 && 
                thumbDistance < 0.2 && middleDistance < 0.2 && 
                ringDistance < 0.2 && pinkyDistance < 0.2) {
                return "指向手势";
            }
            
            return "未知手势";
        }
        
        // 计算两点之间的距离
        function distance(point1, point2) {
            return Math.sqrt(
                Math.pow(point1.x - point2.x, 2) + 
                Math.pow(point1.y - point2.y, 2)
            );
        }

        // ==========================================
        // 7. 自定义手势功能
        // ==========================================
        
        // 7.1 手势特征提取
        function extractFeatures(landmarks) {
            // 提取手部关键点的相对位置作为特征
            const features = [];
            const wrist = landmarks[0];
            
            // 计算所有关键点相对于手腕的位置
            for (let i = 0; i < landmarks.length; i++) {
                // 使用相对坐标，减少手的位置和大小的影响
                const relativeX = landmarks[i].x - wrist.x;
                const relativeY = landmarks[i].y - wrist.y;
                const relativeZ = landmarks[i].z - wrist.z;
                
                features.push(relativeX, relativeY, relativeZ);
            }
            
            return features;
        }
        
        // 7.2 计算手势特征统计信息
        function calculateGestureStats(samples) {
            if (!samples || samples.length === 0) {
                return null;
            }
            
            const stats = {
                sampleCount: samples.length,
                featureDimensions: samples[0].length,
                meanFeatures: [],
                minFeatures: [],
                maxFeatures: [],
                variance: []
            };
            
            // 初始化数组
            for (let i = 0; i < stats.featureDimensions; i++) {
                stats.meanFeatures[i] = 0;
                stats.minFeatures[i] = Infinity;
                stats.maxFeatures[i] = -Infinity;
            }
            
            // 计算总和、最小值和最大值
            for (const sample of samples) {
                for (let i = 0; i < sample.length; i++) {
                    stats.meanFeatures[i] += sample[i];
                    stats.minFeatures[i] = Math.min(stats.minFeatures[i], sample[i]);
                    stats.maxFeatures[i] = Math.max(stats.maxFeatures[i], sample[i]);
                }
            }
            
            // 计算平均值
            for (let i = 0; i < stats.featureDimensions; i++) {
                stats.meanFeatures[i] /= stats.sampleCount;
            }
            
            // 计算方差
            for (let i = 0; i < stats.featureDimensions; i++) {
                let sumSqDiff = 0;
                for (const sample of samples) {
                    const diff = sample[i] - stats.meanFeatures[i];
                    sumSqDiff += diff * diff;
                }
                stats.variance[i] = sumSqDiff / stats.sampleCount;
            }
            
            return stats;
        }
        
        // 7.3 录制样本
        function recordSample(landmarks) {
            if (recordedSamples.length >= 20) {
                stopRecording();
                logToTerminal('已达到最大样本数(20)，自动停止录制');
                return;
            }
            
            const features = extractFeatures(landmarks);
            recordedSamples.push(features);
            
            // 更新样本计数
            samplesCount.textContent = recordedSamples.length;
            
            // 每5个样本记录一次
            if (recordedSamples.length % 5 === 0) {
                logToTerminal(`已录制 ${recordedSamples.length} 个样本`);
            }
        }
        
        // 7.4 开始录制
        function startRecording() {
            const gestureName = gestureNameInput.value.trim();
            
            if (!gestureName) {
                logToTerminal('错误: 请先输入手势名称');
                return;
            }
            
            if (isRecording) {
                logToTerminal('错误: 已经在录制中');
                return;
            }
            
            currentGestureName = gestureName;
            recordedSamples = [];
            isRecording = true;
            
            // 更新UI
            recordingIndicator.classList.add('active');
            startRecordingBtn.disabled = true;
            stopRecordingBtn.disabled = false;
            trainGestureBtn.disabled = true;
            gestureNameInput.disabled = true;
            samplesCount.textContent = '0';
            
            logToTerminal(`开始录制手势: "${gestureName}"`);
            logToTerminal('请保持手势姿势，系统将自动录制样本...');
        }
        
        // 7.5 停止录制
        function stopRecording() {
            if (!isRecording) {
                logToTerminal('错误: 当前没有在录制');
                return;
            }
            
            isRecording = false;
            
            // 更新UI
            recordingIndicator.classList.remove('active');
            startRecordingBtn.disabled = false;
            stopRecordingBtn.disabled = true;
            gestureNameInput.disabled = false;
            
            if (recordedSamples.length > 0) {
                trainGestureBtn.disabled = false;
                logToTerminal(`录制完成，共录制 ${recordedSamples.length} 个样本`);
                logToTerminal('点击"训练模型"按钮来保存这个手势');
            } else {
                logToTerminal('录制完成，但没有录制到任何样本');
            }
        }
        
        // 7.6 训练自定义手势模型
        function trainCustomGesture() {
            if (recordedSamples.length < 5) {
                logToTerminal('错误: 需要至少5个样本来训练手势');
                return;
            }
            
            if (!currentGestureName) {
                logToTerminal('错误: 手势名称不能为空');
                return;
            }
            
            isTraining = true;
            trainGestureBtn.disabled = true;
            trainGestureBtn.innerHTML = '<i class="fas fa-cog fa-spin"></i> 训练中...';
            
            // 模拟训练过程
            setTimeout(() => {
                // 计算特征统计信息
                const stats = calculateGestureStats(recordedSamples);
                
                // 保存手势数据
                const gestureData = {
                    name: currentGestureName,
                    samples: recordedSamples,
                    timestamp: Date.now(),
                    sampleCount: recordedSamples.length,
                    stats: stats
                };
                
                // 检查是否已存在同名手势
                const existingIndex = customGestures.findIndex(g => g.name === currentGestureName);
                if (existingIndex >= 0) {
                    // 替换现有手势
                    customGestures[existingIndex] = gestureData;
                    logToTerminal(`已更新手势: "${currentGestureName}"`);
                } else {
                    // 添加新手势
                    customGestures.push(gestureData);
                    logToTerminal(`已保存新手势: "${currentGestureName}"`);
                }
                
                // 保存到本地存储
                saveCustomGesturesToStorage();
                
                // 重新训练分类器
                trainClassifier();
                
                // 更新UI
                updateCustomGestureList();
                updateCustomGesturesCount();
                
                // 重置状态
                isTraining = false;
                trainGestureBtn.disabled = true;
                trainGestureBtn.innerHTML = '<i class="fas fa-brain"></i> 训练模型';
                recordedSamples = [];
                samplesCount.textContent = '0';
                gestureNameInput.value = '';
                currentGestureName = '';
                
                logToTerminal(`手势训练完成，现在可以识别"${gestureData.name}"`);
            }, 1000);
        }
        
        // 7.7 训练分类器（简单的KNN实现）
        function trainClassifier() {
            if (customGestures.length === 0) {
                gestureClassifier = null;
                return;
            }
            
            // 简单的最近邻分类器
            gestureClassifier = {
                gestures: customGestures,
                
                // 预测手势
                predict: function(features) {
                    let minDistance = Infinity;
                    let predictedGesture = null;
                    
                    // 计算与每个手势的平均距离
                    for (const gesture of this.gestures) {
                        let totalDistance = 0;
                        
                        // 计算与每个样本的距离
                        for (const sample of gesture.samples) {
                            totalDistance += euclideanDistance(features, sample);
                        }
                        
                        // 平均距离
                        const avgDistance = totalDistance / gesture.samples.length;
                        
                        // 更新最小距离
                        if (avgDistance < minDistance) {
                            minDistance = avgDistance;
                            predictedGesture = gesture.name;
                        }
                    }
                    
                    // 设置阈值，避免误识别
                    const threshold = 0.5;
                    if (minDistance < threshold) {
                        return predictedGesture;
                    }
                    
                    return null;
                }
            };
            
            logToTerminal(`分类器训练完成，可识别 ${customGestures.length} 个自定义手势`);
        }
        
        // 计算欧氏距离
        function euclideanDistance(arr1, arr2) {
            if (arr1.length !== arr2.length) {
                return Infinity;
            }
            
            let sum = 0;
            for (let i = 0; i < arr1.length; i++) {
                sum += Math.pow(arr1[i] - arr2[i], 2);
            }
            
            return Math.sqrt(sum);
        }
        
        // 7.8 匹配自定义手势
        function matchCustomGesture(landmarks) {
            if (!gestureClassifier || customGestures.length === 0) {
                return null;
            }
            
            const features = extractFeatures(landmarks);
            return gestureClassifier.predict(features);
        }
        
        // 7.9 更新自定义手势列表
        function updateCustomGestureList() {
            customGestureList.innerHTML = '';
            
            if (customGestures.length === 0) {
                customGestureList.innerHTML = '<div style="color: #888; text-align: center; padding: 20px;">暂无自定义手势</div>';
                return;
            }
            
            // 按时间倒序排序
            const sortedGestures = [...customGestures].sort((a, b) => b.timestamp - a.timestamp);
            
            sortedGestures.forEach((gesture, index) => {
                const item = document.createElement('div');
                item.className = 'custom-gesture-item';
                
                const time = new Date(gesture.timestamp);
                const timeString = `${time.getHours().toString().padStart(2, '0')}:${time.getMinutes().toString().padStart(2, '0')}`;
                
                item.innerHTML = `
                    <div class="custom-gesture-info">
                        <div class="custom-gesture-name">${gesture.name}</div>
                        <div class="custom-gesture-samples">${gesture.sampleCount} 个样本 | ${timeString}</div>
                    </div>
                    <div class="custom-gesture-actions">
                        <button class="custom-gesture-btn" data-action="features" data-index="${index}">特征</button>
                        <button class="custom-gesture-btn" data-action="test" data-index="${index}">测试</button>
                        <button class="custom-gesture-btn" data-action="delete" data-index="${index}">删除</button>
                    </div>
                `;
                
                customGestureList.appendChild(item);
            });
            
            // 添加事件监听器
            document.querySelectorAll('.custom-gesture-btn[data-action="features"]').forEach(btn => {
                btn.addEventListener('click', function() {
                    const index = parseInt(this.getAttribute('data-index'));
                    showGestureFeatures(index);
                });
            });
            
            document.querySelectorAll('.custom-gesture-btn[data-action="test"]').forEach(btn => {
                btn.addEventListener('click', function() {
                    const index = parseInt(this.getAttribute('data-index'));
                    testCustomGesture(index);
                });
            });
            
            document.querySelectorAll('.custom-gesture-btn[data-action="delete"]').forEach(btn => {
                btn.addEventListener('click', function() {
                    const index = parseInt(this.getAttribute('data-index'));
                    deleteCustomGesture(index);
                });
            });
        }
        
        // 7.10 显示手势特征值
        function showGestureFeatures(index) {
            if (index < 0 || index >= customGestures.length) {
                logToTerminal('错误: 手势索引无效');
                return;
            }
            
            const gesture = customGestures[index];
            
            // 更新特征值查看器内容
            updateFeatureViewer(gesture);
            
            // 显示特征值查看器
            featureViewer.classList.add('active');
            
            // 隐藏其他查看器
            codeViewer.classList.remove('active');
            toggleCodeViewerBtn.classList.remove('active');
            toggleCodeViewerBtn.innerHTML = '<i class="fas fa-code"></i> 查看代码';
            
            logToTerminal(`查看手势特征: "${gesture.name}"`);
        }
        
        // 7.11 更新特征值查看器
        function updateFeatureViewer(gesture) {
            let content = '';
            
            // 基本信息
            content += `<div class="feature-item">
                <span class="feature-key">手势名称:</span>
                <span class="feature-value">${gesture.name}</span>
            </div>`;
            
            content += `<div class="feature-item">
                <span class="feature-key">样本数量:</span>
                <span class="feature-value">${gesture.sampleCount}</span>
            </div>`;
            
            content += `<div class="feature-item">
                <span class="feature-key">录制时间:</span>
                <span class="feature-value">${new Date(gesture.timestamp).toLocaleString()}</span>
            </div>`;
            
            // 特征统计信息
            if (gesture.stats) {
                content += `<div class="feature-item">
                    <span class="feature-key">特征维度:</span>
                    <span class="feature-value">${gesture.stats.featureDimensions} (21个关键点 × 3个坐标轴)</span>
                </div>`;
                
                // 显示平均特征向量（前10个值）
                content += `<div class="feature-sample">
                    <div class="feature-sample-title">平均特征向量 (前10个值):</div>
                    <div class="feature-value">${gesture.stats.meanFeatures.slice(0, 10).map((val, i) => 
                        `<div>特征[${i}] = ${val.toFixed(4)}</div>`
                    ).join('')}</div>
                </div>`;
                
                // 显示特征范围
                content += `<div class="feature-sample">
                    <div class="feature-sample-title">特征值范围 (前5个特征):</div>
                    <div class="feature-value">${gesture.stats.minFeatures.slice(0, 5).map((minVal, i) => {
                        const maxVal = gesture.stats.maxFeatures[i];
                        return `<div>特征[${i}]: ${minVal.toFixed(4)} ~ ${maxVal.toFixed(4)}</div>`;
                    }).join('')}</div>
                </div>`;
                
                // 显示方差（前5个）
                content += `<div class="feature-sample">
                    <div class="feature-sample-title">特征方差 (前5个):</div>
                    <div class="feature-value">${gesture.stats.variance.slice(0, 5).map((varVal, i) => 
                        `<div>特征[${i}] 方差 = ${varVal.toFixed(6)}</div>`
                    ).join('')}</div>
                </div>`;
                
                // 显示所有样本的原始特征值
                content += `<div class="feature-sample">
                    <div class="feature-sample-title">样本特征值 (第1个样本，前15个值):</div>
                    <div class="feature-value">${gesture.samples[0].slice(0, 15).map((val, i) => 
                        `<div>样本[0][${i}] = ${val.toFixed(4)}</div>`
                    ).join('')}</div>
                </div>`;
            } else {
                content += `<div class="feature-item">
                    <span class="feature-key">统计信息:</span>
                    <span class="feature-value">未计算</span>
                </div>`;
            }
            
            featureContent.innerHTML = content;
        }
        
        // 7.12 测试自定义手势
        function testCustomGesture(index) {
            if (index < 0 || index >= customGestures.length) {
                logToTerminal('错误: 手势索引无效');
                return;
            }
            
            const gesture = customGestures[index];
            logToTerminal(`测试手势: "${gesture.name}" - 请做出相应手势`);
            currentGesture.textContent = `[测试] ${gesture.name}`;
            currentGesture.style.color = '#ffaa00';
            
            // 3秒后恢复
            setTimeout(() => {
                if (currentGesture.textContent === `[测试] ${gesture.name}`) {
                    currentGesture.textContent = '等待识别...';
                    currentGesture.style.color = '#00ffff';
                }
            }, 3000);
        }
        
        // 7.13 删除自定义手势
        function deleteCustomGesture(index) {
            if (index < 0 || index >= customGestures.length) {
                logToTerminal('错误: 手势索引无效');
                return;
            }
            
            const gesture = customGestures[index];
            if (confirm(`确定要删除手势 "${gesture.name}" 吗？`)) {
                customGestures.splice(index, 1);
                saveCustomGesturesToStorage();
                trainClassifier();
                updateCustomGestureList();
                updateCustomGesturesCount();
                logToTerminal(`已删除手势: "${gesture.name}"`);
                
                // 如果特征查看器正在显示这个手势，关闭它
                if (featureViewer.classList.contains('active')) {
                    featureViewer.classList.remove('active');
                }
            }
        }
        
        // 7.14 保存自定义手势到本地存储
        function saveCustomGesturesToStorage() {
            try {
                // 简化数据以节省存储空间
                const simplifiedGestures = customGestures.map(gesture => ({
                    name: gesture.name,
                    samples: gesture.samples,
                    timestamp: gesture.timestamp,
                    sampleCount: gesture.sampleCount,
                    stats: gesture.stats
                }));
                
                localStorage.setItem('customGestures', JSON.stringify(simplifiedGestures));
                logToTerminal('自定义手势已保存到本地存储');
            } catch (error) {
                console.error('保存手势到本地存储失败:', error);
                logToTerminal('警告: 保存手势到本地存储失败');
            }
        }
        
        // 7.15 从本地存储加载自定义手势
        function loadCustomGesturesFromStorage() {
            try {
                const savedGestures = localStorage.getItem('customGestures');
                if (savedGestures) {
                    const parsedGestures = JSON.parse(savedGestures);
                    customGestures = parsedGestures;
                    trainClassifier();
                    updateCustomGestureList();
                    updateCustomGesturesCount();
                    logToTerminal(`从本地存储加载了 ${customGestures.length} 个自定义手势`);
                }
            } catch (error) {
                console.error('从本地存储加载手势失败:', error);
                logToTerminal('警告: 从本地存储加载手势失败');
            }
        }
        
        // 7.16 更新自定义手势计数
        function updateCustomGesturesCount() {
            customGesturesCount.textContent = customGestures.length;
            if (customGestures.length > 0) {
                customGesturesCount.className = 'status-value good';
            } else {
                customGesturesCount.className = 'status-value warning';
            }
        }

        // ==========================================
        // 8. 视频遮罩功能
        // ==========================================
        function initMaskControl() {
            // 设置初始遮罩透明度
            updateMaskOpacity(maskSlider.value);
            
            // 添加滑块事件监听
            maskSlider.addEventListener('input', function() {
                updateMaskOpacity(this.value);
            });
        }
        
        function updateMaskOpacity(value) {
            maskOpacity = value / 100;
            videoMask.style.backgroundColor = `rgba(0, 0, 0, ${maskOpacity})`;
            maskValue.textContent = `${value}%`;
        }

        // ==========================================
        // 9. 更新显示信息
        // ==========================================
        function updateDetectionInfo(results) {
            if (results.multiHandLandmarks) {
                handsDetected.textContent = results.multiHandLandmarks.length;
                
                if (results.multiHandLandmarks.length > 0) {
                    // 使用第一个手的检测置信度
                    if (results.multiHandWorldLandmarks) {
                        detectionConfidence.textContent = '高';
                    } else {
                        detectionConfidence.textContent = '中';
                    }
                }
            }
        }
        
        function updateGestureDisplay(gesture) {
            currentGesture.textContent = gesture;
            
            // 自定义手势使用不同颜色
            if (gesture.startsWith('[自定义]')) {
                currentGesture.style.color = '#ffaa00';
            } else {
                currentGesture.style.color = '#00ffff';
            }
            
            // 添加到历史记录
            addToHistory(gesture);
            
            // 记录到终端
            logToTerminal(`检测到手势: ${gesture}`);
        }
        
        function addToHistory(gesture) {
            const now = new Date();
            const timeString = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;
            
            // 添加到数组
            gestureHistory.unshift({
                gesture: gesture,
                time: timeString
            });
            
            // 限制历史记录数量
            if (gestureHistory.length > 10) {
                gestureHistory.pop();
            }
            
            // 更新历史记录显示
            updateHistoryDisplay();
        }
        
        function updateHistoryDisplay() {
            // 清空现有列表
            historyList.innerHTML = '';
            
            // 添加历史记录
            gestureHistory.forEach(item => {
                const li = document.createElement('li');
                li.className = 'history-item';
                li.innerHTML = `
                    <span>${item.gesture}</span>
                    <span class="history-time">${item.time}</span>
                `;
                historyList.appendChild(li);
            });
            
            // 更新计数
            historyCount.textContent = `${gestureHistory.length} 条记录`;
        }
        
        function updateFPS() {
            frameCount++;
            const now = Date.now();
            const delta = now - lastFrameTime;
            
            if (delta >= 1000) {
                currentFPS = Math.round((frameCount * 1000) / delta);
                fpsCounter.textContent = `FPS: ${currentFPS}`;
                frameCount = 0;
                lastFrameTime = now;
            }
        }

        // ==========================================
        // 10. 终端日志功能
        // ==========================================
        function logToTerminal(message) {
            const now = new Date();
            const timeString = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;
            
            // 添加到数组
            terminalLogs.push({
                message: message,
                time: timeString
            });
            
            // 限制日志数量
            if (terminalLogs.length > 20) {
                terminalLogs.shift();
            }
            
            // 更新终端显示
            updateTerminalDisplay();
        }
        
        function updateTerminalDisplay() {
            // 清空终端
            terminalOutput.innerHTML = '';
            
            // 添加日志
            terminalLogs.forEach(log => {
                const line = document.createElement('div');
                line.className = 'terminal-line';
                line.innerHTML = `<span class="terminal-prompt">[${log.time}]</span> ${log.message}`;
                terminalOutput.appendChild(line);
            });
            
            // 滚动到底部
            terminalOutput.scrollTop = terminalOutput.scrollHeight;
        }

        // ==========================================
        // 11. 摄像头管理
        // ==========================================
        async function initCamera() {
            logToTerminal('正在初始化摄像头...');
            
            try {
                // 获取摄像头设备列表
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                
                if (videoDevices.length === 0) {
                    throw new Error('未找到可用的摄像头设备');
                }
                
                // 使用第一个摄像头
                const constraints = {
                    video: {
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        facingMode: 'user'
                    }
                };
                
                currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                videoElement.srcObject = currentStream;
                
                // 等待视频加载
                await new Promise((resolve) => {
                    videoElement.onloadedmetadata = () => {
                        resolve();
                    };
                });
                
                // 设置画布尺寸与视频一致
                canvasElement.width = videoElement.videoWidth;
                canvasElement.height = videoElement.videoHeight;
                
                // 更新状态
                cameraStatus.textContent = '已连接';
                cameraStatus.className = 'status-value good';
                
                // 初始化摄像头工具
                camera = new Camera(videoElement, {
                    onFrame: async () => {
                        if (detectionActive) {
                            await hands.send({image: videoElement});
                        }
                    },
                    width: videoElement.videoWidth,
                    height: videoElement.videoHeight
                });
                
                // 启动摄像头
                await camera.start();
                logToTerminal('摄像头初始化完成。');
                
                // 隐藏加载界面
                setTimeout(() => {
                    loader.style.opacity = '0';
                    setTimeout(() => {
                        loader.style.display = 'none';
                        logToTerminal('系统就绪，等待手势输入...');
                    }, 500);
                }, 1000);
                
            } catch (error) {
                console.error('摄像头初始化失败:', error);
                logToTerminal(`摄像头初始化失败: ${error.message}`);
                cameraStatus.textContent = '连接失败';
                cameraStatus.className = 'status-value error';
                
                // 显示备用图像
                videoElement.style.background = '#000';
            }
        }
        
        async function toggleCamera() {
            if (!currentStream) return;
            
            try {
                // 获取所有摄像头设备
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                
                if (videoDevices.length < 2) {
                    logToTerminal('警告: 只找到一个摄像头，无法切换。');
                    return;
                }
                
                // 停止当前流
                currentStream.getTracks().forEach(track => track.stop());
                
                // 获取当前摄像头ID
                const currentTrack = currentStream.getVideoTracks()[0];
                const currentDeviceId = currentTrack.getSettings().deviceId;
                
                // 查找下一个摄像头
                let nextDeviceIndex = 0;
                for (let i = 0; i < videoDevices.length; i++) {
                    if (videoDevices[i].deviceId === currentDeviceId) {
                        nextDeviceIndex = (i + 1) % videoDevices.length;
                        break;
                    }
                }
                
                // 使用下一个摄像头
                const constraints = {
                    video: {
                        deviceId: { exact: videoDevices[nextDeviceIndex].deviceId },
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                };
                
                currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                videoElement.srcObject = currentStream;
                
                // 等待视频加载
                await new Promise((resolve) => {
                    videoElement.onloadedmetadata = () => {
                        resolve();
                    };
                });
                
                // 更新画布尺寸
                canvasElement.width = videoElement.videoWidth;
                canvasElement.height = videoElement.videoHeight;
                
                logToTerminal(`已切换到摄像头: ${videoDevices[nextDeviceIndex].label || '未知摄像头'}`);
                
            } catch (error) {
                console.error('切换摄像头失败:', error);
                logToTerminal(`切换摄像头失败: ${error.message}`);
            }
        }

        // ==========================================
        // 12. 代码查看器功能
        // ==========================================
        function showCodeViewer() {
            codeViewer.classList.add('active');
            updateCodeViewer();
        }
        
        function hideCodeViewer() {
            codeViewer.classList.remove('active');
        }
        
        function updateCodeViewer() {
            const code = `
<span class="code-comment">// ==========================================</span>
<span class="code-comment">// 自定义手势识别核心代码</span>
<span class="code-comment">// ==========================================</span>

<span class="code-comment">// 1. 手势特征提取函数</span>
<span class="code-keyword">function</span> <span class="code-function">extractFeatures</span>(landmarks) {
    <span class="code-keyword">const</span> features = [];
    <span class="code-keyword">const</span> wrist = landmarks[<span class="code-number">0</span>];
    
    <span class="code-comment">// 计算所有关键点相对于手腕的位置</span>
    <span class="code-keyword">for</span> (<span class="code-keyword">let</span> i = <span class="code-number">0</span>; i < landmarks.length; i++) {
        <span class="code-keyword">const</span> relativeX = landmarks[i].x - wrist.x;
        <span class="code-keyword">const</span> relativeY = landmarks[i].y - wrist.y;
        <span class="code-keyword">const</span> relativeZ = landmarks[i].z - wrist.z;
        
        features.push(relativeX, relativeY, relativeZ);
    }
    
    <span class="code-keyword">return</span> features;
}

<span class="code-comment">// 2. 最近邻分类器实现</span>
<span class="code-keyword">function</span> <span class="code-function">trainClassifier</span>() {
    <span class="code-keyword">if</span> (customGestures.length === <span class="code-number">0</span>) {
        gestureClassifier = <span class="code-keyword">null</span>;
        <span class="code-keyword">return</span>;
    }
    
    <span class="code-comment">// 简单的最近邻分类器</span>
    gestureClassifier = {
        gestures: customGestures,
        
        <span class="code-comment">// 预测手势</span>
        predict: <span class="code-keyword">function</span>(features) {
            <span class="code-keyword">let</span> minDistance = <span class="code-keyword">Infinity</span>;
            <span class="code-keyword">let</span> predictedGesture = <span class="code-keyword">null</span>;
            
            <span class="code-comment">// 计算与每个手势的平均距离</span>
            <span class="code-keyword">for</span> (<span class="code-keyword">const</span> gesture <span class="code-keyword">of</span> <span class="code-keyword">this</span>.gestures) {
                <span class="code-keyword">let</span> totalDistance = <span class="code-number">0</span>;
                
                <span class="code-comment">// 计算与每个样本的距离</span>
                <span class="code-keyword">for</span> (<span class="code-keyword">const</span> sample <span class="code-keyword">of</span> gesture.samples) {
                    totalDistance += euclideanDistance(features, sample);
                }
                
                <span class="code-comment">// 平均距离</span>
                <span class="code-keyword">const</span> avgDistance = totalDistance / gesture.samples.length;
                
                <span class="code-comment">// 更新最小距离</span>
                <span class="code-keyword">if</span> (avgDistance < minDistance) {
                    minDistance = avgDistance;
                    predictedGesture = gesture.name;
                }
            }
            
            <span class="code-comment">// 设置阈值，避免误识别</span>
            <span class="code-keyword">const</span> threshold = <span class="code-number">0.5</span>;
            <span class="code-keyword">if</span> (minDistance < threshold) {
                <span class="code-keyword">return</span> predictedGesture;
            }
            
            <span class="code-keyword">return</span> <span class="code-keyword">null</span>;
        }
    };
}

<span class="code-comment">// 3. 欧氏距离计算函数</span>
<span class="code-keyword">function</span> <span class="code-function">euclideanDistance</span>(arr1, arr2) {
    <span class="code-keyword">if</span> (arr1.length !== arr2.length) {
        <span class="code-keyword">return</span> <span class="code-keyword">Infinity</span>;
    }
    
    <span class="code-keyword">let</span> sum = <span class="code-number">0</span>;
    <span class="code-keyword">for</span> (<span class="code-keyword">let</span> i = <span class="code-number">0</span>; i < arr1.length; i++) {
        sum += Math.pow(arr1[i] - arr2[i], <span class="code-number">2</span>);
    }
    
    <span class="code-keyword">return</span> Math.sqrt(sum);
}

<span class="code-comment">// 4. 手势匹配函数</span>
<span class="code-keyword">function</span> <span class="code-function">matchCustomGesture</span>(landmarks) {
    <span class="code-keyword">if</span> (!gestureClassifier || customGestures.length === <span class="code-number">0</span>) {
        <span class="code-keyword">return</span> <span class="code-keyword">null</span>;
    }
    
    <span class="code-keyword">const</span> features = extractFeatures(landmarks);
    <span class="code-keyword">return</span> gestureClassifier.predict(features);
}

<span class="code-comment">// 5. 本地存储管理</span>
<span class="code-keyword">function</span> <span class="code-function">saveCustomGesturesToStorage</span>() {
    <span class="code-keyword">try</span> {
        <span class="code-comment">// 简化数据以节省存储空间</span>
        <span class="code-keyword">const</span> simplifiedGestures = customGestures.map(gesture => ({
            name: gesture.name,
            samples: gesture.samples,
            timestamp: gesture.timestamp,
            sampleCount: gesture.sampleCount
        }));
        
        localStorage.setItem(<span class="code-string">'customGestures'</span>, JSON.stringify(simplifiedGestures));
    } <span class="code-keyword">catch</span> (error) {
        console.error(<span class="code-string">'保存手势到本地存储失败:'</span>, error);
    }
}

<span class="code-comment">// 6. 录制样本函数</span>
<span class="code-keyword">function</span> <span class="code-function">recordSample</span>(landmarks) {
    <span class="code-keyword">if</span> (recordedSamples.length >= <span class="code-number">20</span>) {
        stopRecording();
        <span class="code-keyword">return</span>;
    }
    
    <span class="code-keyword">const</span> features = extractFeatures(landmarks);
    recordedSamples.push(features);
    
    <span class="code-comment">// 更新样本计数显示</span>
    samplesCount.textContent = recordedSamples.length;
}
            `;
            
            codeContent.innerHTML = code;
        }

        // ==========================================
        // 13. 控制按钮事件处理
        // ==========================================
        function setupEventListeners() {
            // 切换摄像头按钮
            document.getElementById('toggle-camera').addEventListener('click', toggleCamera);
            
            // 切换视觉标识按钮
            document.getElementById('toggle-visuals').addEventListener('click', function() {
                showVisuals = !showVisuals;
                this.classList.toggle('active', showVisuals);
                this.innerHTML = showVisuals ? 
                    '<i class="fas fa-eye"></i> 隐藏关键点' : 
                    '<i class="fas fa-eye-slash"></i> 显示关键点';
                logToTerminal(showVisuals ? '已显示手部关键点' : '已隐藏手部关键点');
            });
            
            // 切换自定义手势面板
            toggleCustomGestureBtn.addEventListener('click', function() {
                customGesturePanel.classList.toggle('active');
                this.classList.toggle('active', customGesturePanel.classList.contains('active'));
                this.innerHTML = customGesturePanel.classList.contains('active') ? 
                    '<i class="fas fa-times"></i> 关闭自定义' : 
                    '<i class="fas fa-hand-sparkles"></i> 自定义手势';
                
                if (customGesturePanel.classList.contains('active')) {
                    logToTerminal('已打开自定义手势面板');
                }
            });
            
            // 关闭自定义手势面板
            closeCustomPanelBtn.addEventListener('click', function() {
                customGesturePanel.classList.remove('active');
                toggleCustomGestureBtn.classList.remove('active');
                toggleCustomGestureBtn.innerHTML = '<i class="fas fa-hand-sparkles"></i> 自定义手势';
                logToTerminal('已关闭自定义手势面板');
            });
            
            // 关闭特征值查看器
            closeFeatureViewerBtn.addEventListener('click', function() {
                featureViewer.classList.remove('active');
                logToTerminal('已关闭特征值查看器');
            });
            
            // 切换代码查看器
            toggleCodeViewerBtn.addEventListener('click', function() {
                codeViewer.classList.toggle('active');
                this.classList.toggle('active', codeViewer.classList.contains('active'));
                this.innerHTML = codeViewer.classList.contains('active') ? 
                    '<i class="fas fa-times"></i> 关闭代码' : 
                    '<i class="fas fa-code"></i> 查看代码';
                
                if (codeViewer.classList.contains('active')) {
                    updateCodeViewer();
                    logToTerminal('已打开代码查看器');
                    
                    // 关闭特征值查看器
                    featureViewer.classList.remove('active');
                }
            });
            
            // 关闭代码查看器
            closeCodeViewerBtn.addEventListener('click', function() {
                codeViewer.classList.remove('active');
                toggleCodeViewerBtn.classList.remove('active');
                toggleCodeViewerBtn.innerHTML = '<i class="fas fa-code"></i> 查看代码';
                logToTerminal('已关闭代码查看器');
            });
            
            // 清除历史按钮
            document.getElementById('clear-history').addEventListener('click', function() {
                gestureHistory = [];
                updateHistoryDisplay();
                logToTerminal('手势历史记录已清除');
            });
            
            // 自定义手势相关按钮
            startRecordingBtn.addEventListener('click', startRecording);
            stopRecordingBtn.addEventListener('click', stopRecording);
            trainGestureBtn.addEventListener('click', trainCustomGesture);
        }

        // ==========================================
        // 14. 时间戳更新
        // ==========================================
        function updateTimestamp() {
            const now = new Date();
            const timeString = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;
            timestamp.textContent = timeString;
        }

        // ==========================================
        // 15. 系统初始化
        // ==========================================
        async function initSystem() {
            // 更新初始时间戳
            updateTimestamp();
            setInterval(updateTimestamp, 1000);
            
            // 初始化数据流背景
            initDataStream();
            
            // 初始化视频遮罩控制
            initMaskControl();
            
            // 初始化MediaPipe
            initializeMediaPipe();
            
            // 从本地存储加载自定义手势
            loadCustomGesturesFromStorage();
            
            // 初始化摄像头
            await initCamera();
            
            // 设置事件监听器
            setupEventListeners();
            
            // 初始日志
            logToTerminal('系统初始化完成。');
            logToTerminal(`已加载 ${customGestures.length} 个自定义手势`);
        }

        // ==========================================
        // 16. 启动系统
        // ==========================================
        window.addEventListener('DOMContentLoaded', initSystem);
        
        // 窗口大小调整处理
        window.addEventListener('resize', function() {
            if (videoElement.videoWidth && videoElement.videoHeight) {
                canvasElement.width = videoElement.videoWidth;
                canvasElement.height = videoElement.videoHeight;
            }
        });
    </script>
</body>
</html>
